"use strict";(self.webpackChunkrehowl=self.webpackChunkrehowl||[]).push([[319],{"./stories/Play.stories.tsx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{__namedExportsOrder:()=>__namedExportsOrder,basicSprite:()=>basicSprite,complexSprite:()=>complexSprite,default:()=>Play_stories,errorBadSRC:()=>errorBadSRC,fade:()=>fade,howlDefaultVolume:()=>howlDefaultVolume,mute:()=>mute,noPreload:()=>noPreload,pause:()=>pause,rate:()=>rate,renderPlay:()=>renderPlay,seekWithScrubberBar:()=>seekWithScrubberBar,stop:()=>stop,swapSource:()=>swapSource,volume:()=>volume});var react=__webpack_require__("./node_modules/react/index.js"),react_namespaceObject=__webpack_require__.t(react,2),useHowl=__webpack_require__("./src/useHowl.ts"),Play=__webpack_require__("./src/Play.tsx"),chunk_AY7I2SME=__webpack_require__("./node_modules/@storybook/addon-actions/dist/chunk-AY7I2SME.mjs"),sound1=__webpack_require__("./stories/static/audio/sound1.mp3");const sound2_namespaceObject=__webpack_require__.p+"static/media/sound2.a3c4ec16.mp3",static_audio_sound2_namespaceObject=__webpack_require__.p+"static/media/sound2.99003ab6.webm";var jsx_runtime=__webpack_require__("./node_modules/react/jsx-runtime.js");const{useState,useEffect,useRef}=react_namespaceObject,Play_stories={title:"Components/Play",component:Play.s,tags:["autodocs"]},PlayPauseButton=_ref=>{let{play,setPlay}=_ref;return(0,jsx_runtime.jsx)("p",{children:(0,jsx_runtime.jsx)("button",{onClick:()=>setPlay(!play),children:play?"Pause ⏸":"Play ▶"})})};PlayPauseButton.displayName="PlayPauseButton";const renderPlay=()=>{const{howl,state}=(0,useHowl.$)({src:sound1}),[play,setPlay]=useState(!1);return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsx)("p",{children:"Sound stops when the Play component is unmounted."}),(0,jsx_runtime.jsxs)("p",{children:["State: ",state]}),(0,jsx_runtime.jsx)(PlayPauseButton,{play,setPlay}),play?(0,jsx_runtime.jsx)(Play.s,{howl,children:_ref2=>{let{playing}=_ref2;return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:["This is the child of the play component! Playing: ",playing().toString()]})}}):null]})},noPreload=()=>{const{howl,state,load,error}=(0,useHowl.$)({src:sound1,preload:!1}),[play,setPlay]=useState(!1);return useEffect((()=>{(0,chunk_AY7I2SME.aD)(state)()}),[state]),(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsx)("p",{children:"The Play component will not be able to do anything until you call load."}),(0,jsx_runtime.jsxs)("p",{children:["State: ",state]}),"unloaded"===state&&(0,jsx_runtime.jsx)("button",{onClick:()=>load(),children:"Load"}),(0,jsx_runtime.jsx)(PlayPauseButton,{play,setPlay}),play&&(0,jsx_runtime.jsx)(Play.s,{howl,onPlayError:(0,chunk_AY7I2SME.aD)("onPlayError"),children:_ref3=>{let{playing}=_ref3;return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:["Playing: ",playing().toString()]})}})]})},stop=()=>{const{howl,state}=(0,useHowl.$)({src:sound1}),[play,setPlay]=useState(!1);return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsxs)("p",{children:["This component is being stopped with the ",(0,jsx_runtime.jsx)("code",{children:"stop"})," prop."]}),(0,jsx_runtime.jsxs)("p",{children:["State: ",state]}),(0,jsx_runtime.jsx)(PlayPauseButton,{play,setPlay}),(0,jsx_runtime.jsx)(Play.s,{howl,stop:!play,onStop:(0,chunk_AY7I2SME.aD)("onStop"),onPlay:(0,chunk_AY7I2SME.aD)("onPlay"),children:_ref4=>{let{playing}=_ref4;return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:["Playing: ",playing().toString()]})}})]})},rate=()=>{const{howl,state}=(0,useHowl.$)({src:sound1}),[play,setPlay]=useState(!1),[rate,setRate]=useState(2);return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsx)("p",{children:"Control the rate of playback."}),(0,jsx_runtime.jsxs)("p",{children:["State: ",state]}),(0,jsx_runtime.jsxs)("p",{children:["Rate: ",100*rate,"%"]}),(0,jsx_runtime.jsx)(PlayPauseButton,{play,setPlay}),(0,jsx_runtime.jsxs)("p",{children:[(0,jsx_runtime.jsx)("button",{onClick:()=>setRate((rate=>Math.max(rate-.5,.5))),disabled:rate<=.5,children:"-0.5"}),(0,jsx_runtime.jsx)("button",{onClick:()=>setRate((rate=>Math.min(rate+.5,4))),disabled:rate>=4,children:"+0.5"})]}),(0,jsx_runtime.jsx)(Play.s,{howl,rate,onRate:(0,chunk_AY7I2SME.aD)("onRate"),pause:!play,children:_ref5=>{let{playing}=_ref5;return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:["Playing: ",playing().toString()]})}})]})},pause=()=>{const{howl,state}=(0,useHowl.$)({src:sound1}),[play,setPlay]=useState(!1);return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsxs)("p",{children:["Control playback with the ",(0,jsx_runtime.jsx)("code",{children:"pause"})," prop."]}),(0,jsx_runtime.jsxs)("p",{children:["State: ",state]}),(0,jsx_runtime.jsx)(PlayPauseButton,{play,setPlay}),(0,jsx_runtime.jsx)(Play.s,{howl,pause:!play,onPlay:(0,chunk_AY7I2SME.aD)("onPlay"),onPause:(0,chunk_AY7I2SME.aD)("onPause"),children:_ref6=>{let{playing}=_ref6;return(0,jsx_runtime.jsxs)("p",{children:["Playing: ",playing().toString()]})}})]})},volume=()=>{const{howl,state}=(0,useHowl.$)({src:sound1}),[play,setPlay]=useState(!1),[volume,setVolume]=useState(.5);return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsx)("p",{children:"Set the volume. The Play element can change before and during playback."}),(0,jsx_runtime.jsxs)("p",{children:["State: ",state]}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("label",{htmlFor:"volume",children:"Volume:"}),(0,jsx_runtime.jsx)("input",{id:"volume",type:"range",min:0,max:1,step:.05,value:volume,onChange:event=>setVolume(parseFloat(event.target.value))})]}),(0,jsx_runtime.jsx)(PlayPauseButton,{play,setPlay}),play&&(0,jsx_runtime.jsx)(Play.s,{howl,volume,onVolume:(0,chunk_AY7I2SME.aD)("onVolume"),children:_ref7=>{let{playing}=_ref7;return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:["Playing: ",playing().toString()]})}})]})},mute=()=>{const{howl,state}=(0,useHowl.$)({src:sound1}),[play,setPlay]=useState(!1),[mute,setMute]=useState(!0);return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsxs)("p",{children:["State: ",state]}),(0,jsx_runtime.jsx)(PlayPauseButton,{play,setPlay}),(0,jsx_runtime.jsxs)("p",{children:[mute?"Muted.":"Unmuted."," ",(0,jsx_runtime.jsx)("button",{onClick:()=>setMute(!mute),children:mute?"Unmute 🔊":"Mute 🔇"})]}),play&&(0,jsx_runtime.jsx)(Play.s,{howl,mute,onPlay:(0,chunk_AY7I2SME.aD)("onPlay"),onMute:(0,chunk_AY7I2SME.aD)("onMute"),children:_ref8=>{let{playing}=_ref8;return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:["Playing: ",playing().toString()]})}})]})},fade=()=>{const{howl,state}=(0,useHowl.$)({src:sound1}),[play,setPlay]=useState(!1),[silent,setSilent]=useState(void 0),[fading,setFading]=useState(!1),[,setTime]=useState(0),requestRef=useRef(null),previousTimeRef=useRef(0),animate=time=>{if(void 0!==previousTimeRef.current){const deltaTime=time-previousTimeRef.current;setTime(deltaTime)}previousTimeRef.current=time,requestRef.current=requestAnimationFrame(animate)};return useEffect((()=>{if(fading)return requestRef.current=requestAnimationFrame(animate),()=>{requestRef.current&&cancelAnimationFrame(requestRef.current)};requestRef.current&&cancelAnimationFrame(requestRef.current)}),[fading]),(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsxs)("p",{children:["State: ",state]}),(0,jsx_runtime.jsx)(PlayPauseButton,{play,setPlay}),(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsx)("button",{disabled:fading,onClick:()=>{setFading(!0),setSilent(!silent)},children:fading?silent?"Fading out...":"Fading in...":silent?"Fade in!":"Fade out!"}),(0,jsx_runtime.jsx)(Play.s,{howl,pause:!play,fade:void 0===silent?void 0:silent?[1,0,2e3]:[0,1,2e3],onFade:()=>setFading(!1),children:_ref9=>{let{volume}=_ref9;return(0,jsx_runtime.jsxs)("p",{children:["Volume is at ",(100*volume()).toFixed(0),"%"]})}})]})]})},seekWithScrubberBar=()=>{const{howl}=(0,useHowl.$)({src:sound1}),[targetSeek,setTargetSeek]=useState(0),[play,setPlay]=useState(!1),[scrubbing,setScrubbing]=useState(!1),[pauseDuringScrub,setPauseDuringScrub]=useState(!0),[,setTime]=useState(0),requestRef=useRef(null),previousTimeRef=useRef(0),animate=time=>{if(void 0!==previousTimeRef.current){const deltaTime=time-previousTimeRef.current;setTime(deltaTime)}previousTimeRef.current=time,requestRef.current=requestAnimationFrame(animate)};return useEffect((()=>{if(play)return requestRef.current=requestAnimationFrame(animate),()=>{requestRef.current&&cancelAnimationFrame(requestRef.current)}}),[play]),(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("input",{type:"checkbox",checked:pauseDuringScrub,onChange:event=>setPauseDuringScrub(event.target.checked),id:"pause-during-scrub"}),(0,jsx_runtime.jsx)("label",{htmlFor:"pause-during-scrub",children:"Pause while scrubbing"})]}),(0,jsx_runtime.jsx)(PlayPauseButton,{play,setPlay}),(0,jsx_runtime.jsx)(Play.s,{howl,seek:targetSeek,pause:!play||pauseDuringScrub&&scrubbing,onEnd:()=>setPlay(!0),onSeek:(0,chunk_AY7I2SME.aD)("onSeek"),children:_ref10=>{let{seek,duration}=_ref10;const position=scrubbing&&void 0!==targetSeek?targetSeek:seek(),length=duration();return(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsxs)("p",{children:[position.toFixed(1)," / ",length.toFixed(1)]}),(0,jsx_runtime.jsx)("input",{type:"range",min:0,max:length,value:position,step:.1,onChange:e=>{const changedPosition=parseFloat(e.target.value);setTargetSeek(changedPosition)},onMouseDown:()=>setTimeout((()=>setScrubbing(!0)),0),onMouseUp:()=>setTimeout((()=>setScrubbing(!1)),0)})]})}})]})},basicSprite=()=>{const[digit,setDigit]=useState(0),[loop,setLoop]=useState(!1),{howl,state}=(0,useHowl.$)({src:[static_audio_sound2_namespaceObject,sound2_namespaceObject],sprite:{1:[0,450],2:[2e3,250],3:[4e3,350],4:[6e3,380],5:[8e3,340]}});return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsx)("p",{children:"All these digits are loaded from a single sound file and are controlled by one Howl. The Play component will automatically start playing when the selected sprite changes."}),(0,jsx_runtime.jsxs)("p",{children:["Selected digit: ",digit]}),(0,jsx_runtime.jsxs)("p",{children:["State: ",state]}),(0,jsx_runtime.jsx)("div",{children:[1,2,3,4,5].map((digit=>(0,jsx_runtime.jsx)("button",{onClick:()=>{setDigit(digit)},children:digit},digit)))}),(0,jsx_runtime.jsx)("button",{onClick:()=>setLoop(!loop),children:loop?"Disable Looping":"Enable Looping"}),digit>0?(0,jsx_runtime.jsx)(Play.s,{howl,sprite:`${digit}`,loop}):null]})},complexSprite=()=>{const[digits,setDigits]=useState([]),[playBeat,setPlayBeat]=useState(!1),{howl,state}=(0,useHowl.$)({src:[static_audio_sound2_namespaceObject,sound2_namespaceObject],sprite:{1:[0,450],2:[2e3,250],3:[4e3,350],4:[6e3,380],5:[8e3,340],beat:[1e4,11163]}});return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsx)("p",{children:"All these sounds are loaded from a single sound file on one Howl."}),(0,jsx_runtime.jsx)("p",{children:"Every time you click a digit, a Play is rendered and played until onEnd is called."}),(0,jsx_runtime.jsx)("p",{children:"Go ahead, play a few sounds at once."}),(0,jsx_runtime.jsxs)("p",{children:["State: ",state]}),(0,jsx_runtime.jsx)("div",{children:[1,2,3,4,5].map((digit=>(0,jsx_runtime.jsx)("button",{onClick:()=>{setDigits((digits=>[...digits,{digit,time:Date.now()}]))},children:digit},digit)))}),(0,jsx_runtime.jsx)("button",{onClick:()=>setPlayBeat(!playBeat),children:playBeat?"Pause Beat":"Play Beat"}),(0,jsx_runtime.jsx)("button",{onClick:()=>{const now=Date.now();setDigits((digits=>[...digits,{digit:5,time:now},{digit:4,time:now+1},{digit:3,time:now+2},{digit:2,time:now+3},{digit:1,time:now+4}]))},children:"Play all"}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)(Play.s,{howl,sprite:"beat",loop:!0,pause:!playBeat,children:_ref11=>{let{playing}=_ref11;return(0,jsx_runtime.jsxs)("p",{children:["Beat Playing: ",playing().toString()]})}}),digits.map((_ref12=>{let{digit,time}=_ref12;return(0,jsx_runtime.jsx)(Play.s,{howl,sprite:`${digit}`,onEnd:()=>setDigits((digits=>{const targetIndex=digits.findIndex((x=>x.time===time));return targetIndex<0?digits:[...digits.slice(0,targetIndex),...digits.slice(targetIndex+1)]})),children:_ref13=>{let{duration}=_ref13;return(0,jsx_runtime.jsxs)("p",{children:["Playing ",digit," for ",duration()]})}},time)}))]})]})},errorBadSRC=()=>{const{howl,state,error}=(0,useHowl.$)({src:"fake"});return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[error&&(0,jsx_runtime.jsxs)("p",{children:["Error: ",[error.id,error.message].filter((x=>x)).join(" ")," "]}),(0,jsx_runtime.jsxs)("p",{children:["State: ",state]}),(0,jsx_runtime.jsx)(Play.s,{howl})]})},howlDefaultVolume=()=>{const[defaultVolume,setDefaultVolume]=useState(0),[playVolume,setPlayVolume]=useState(0),{howl}=(0,useHowl.$)({src:sound1,defaultVolume}),[play,setPlay]=useState(!1);return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsx)("p",{children:"Default volume on the howl is 0 to prevent clipping on quiet plays. This example is used for debug on slower devices such as phones."}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsxs)("label",{children:[(0,jsx_runtime.jsx)("input",{type:"radio",name:"default-volume",checked:0===defaultVolume,value:0,onChange:event=>{event.target.checked&&setDefaultVolume(0)}})," Default volume 0"]}),(0,jsx_runtime.jsxs)("label",{children:[(0,jsx_runtime.jsx)("input",{type:"radio",name:"default-volume",checked:1===defaultVolume,value:1,onChange:event=>{event.target.checked&&setDefaultVolume(1)}})," Default volume 1"]})]}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsxs)("label",{children:[(0,jsx_runtime.jsx)("input",{type:"radio",name:"play-volume",checked:0===playVolume,value:0,onChange:event=>{event.target.checked&&setPlayVolume(0)}})," Play volume 0"]}),(0,jsx_runtime.jsxs)("label",{children:[(0,jsx_runtime.jsx)("input",{type:"radio",name:"play-volume",checked:1===playVolume,value:1,onChange:event=>{event.target.checked&&setPlayVolume(1)}})," Play volume 1"]})]}),(0,jsx_runtime.jsx)(PlayPauseButton,{play,setPlay}),play&&(0,jsx_runtime.jsx)(Play.s,{howl,volume:playVolume,seek:.5})]})},swapSource=()=>{const srcs=["nonexistent.mp3",sound1,sound2_namespaceObject],[useHtml5,setUseHtml5]=useState(!1),[src,setSrc]=useState(srcs[0]),{howl,state,error}=(0,useHowl.$)({src,html5:useHtml5});return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsx)("p",{children:"Every time a setting is changed on useHowl or Rehowl, the howl instance is reconstructed."}),(0,jsx_runtime.jsx)("p",{children:"It's better to load multiple howls and use Play components than swap the source on a single howl."}),(0,jsx_runtime.jsx)("p",{children:"In this example, you can change the howl's src and whether it's using HTML5 Audio or Web Audio."}),(0,jsx_runtime.jsx)("p",{children:(0,jsx_runtime.jsx)("strong",{children:"Select a sound to play"})}),srcs.map((srcChoice=>(0,jsx_runtime.jsx)("div",{children:(0,jsx_runtime.jsxs)("label",{children:[(0,jsx_runtime.jsx)("input",{type:"radio",name:"source",checked:srcChoice===src,value:srcChoice,onChange:event=>{event.target.checked&&setSrc(srcChoice)}})," ",srcChoice]})},srcChoice))),(0,jsx_runtime.jsxs)("label",{style:{display:"block",marginTop:"1rem"},children:[(0,jsx_runtime.jsx)("input",{type:"checkbox",checked:useHtml5,onChange:event=>setUseHtml5(event.target.checked),id:"html5"}),"Use HTML 5 Audio"]}),(0,jsx_runtime.jsx)("p",{children:(0,jsx_runtime.jsx)("strong",{children:"Info"})}),error&&(0,jsx_runtime.jsxs)("p",{children:["Error: ",[error.id,error.message].filter((x=>x)).join(" ")," "]}),(0,jsx_runtime.jsxs)("p",{children:["State: ",state]}),(0,jsx_runtime.jsx)(Play.s,{howl,children:_ref14=>{let{playing}=_ref14;return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:["Playing: ",playing().toString()]})}})]})};renderPlay.parameters={...renderPlay.parameters,docs:{...renderPlay.parameters?.docs,source:{originalSource:"() => {\n  const {\n    howl,\n    state\n  } = useHowl({\n    src: sound1\n  });\n  const [play, setPlay] = useState(false);\n  return <>\n      <p>Sound stops when the Play component is unmounted.</p>\n      <p>State: {state}</p>\n      <PlayPauseButton play={play} setPlay={setPlay} />\n      {play ? <Play howl={howl}>\n          {({\n        playing\n      }) => <>This is the child of the play component! Playing: {playing().toString()}</>}\n        </Play> : null}\n    </>;\n}",...renderPlay.parameters?.docs?.source}}},noPreload.parameters={...noPreload.parameters,docs:{...noPreload.parameters?.docs,source:{originalSource:"() => {\n  const {\n    howl,\n    state,\n    load,\n    error\n  } = useHowl({\n    src: sound1,\n    preload: false\n  });\n  const [play, setPlay] = useState(false);\n  useEffect(() => {\n    action(state)();\n  }, [state]);\n  return <>\n      <p>The Play component will not be able to do anything until you call load.</p>\n      <p>State: {state}</p>\n      {state === 'unloaded' && <button onClick={() => load()}>Load</button>}\n      <PlayPauseButton play={play} setPlay={setPlay} />\n      {play && <Play howl={howl} onPlayError={action('onPlayError')}>\n          {({\n        playing\n      }) => <>Playing: {playing().toString()}</>}\n        </Play>}\n    </>;\n}",...noPreload.parameters?.docs?.source}}},stop.parameters={...stop.parameters,docs:{...stop.parameters?.docs,source:{originalSource:"() => {\n  const {\n    howl,\n    state\n  } = useHowl({\n    src: sound1\n  });\n  const [play, setPlay] = useState(false);\n  return <>\n      <p>\n        This component is being stopped with the <code>stop</code> prop.\n      </p>\n      <p>State: {state}</p>\n      <PlayPauseButton play={play} setPlay={setPlay} />\n      <Play howl={howl} stop={!play} onStop={action('onStop')} onPlay={action('onPlay')}>\n        {({\n        playing\n      }) => <>Playing: {playing().toString()}</>}\n      </Play>\n    </>;\n}",...stop.parameters?.docs?.source}}},rate.parameters={...rate.parameters,docs:{...rate.parameters?.docs,source:{originalSource:"() => {\n  const {\n    howl,\n    state\n  } = useHowl({\n    src: sound1\n  });\n  const [play, setPlay] = useState(false);\n  const [rate, setRate] = useState(2);\n  const decreaseRate = () => setRate(rate => Math.max(rate - 0.5, 0.5));\n  const increaseRate = () => setRate(rate => Math.min(rate + 0.5, 4));\n  return <>\n      <p>Control the rate of playback.</p>\n      <p>State: {state}</p>\n      <p>Rate: {rate * 100}%</p>\n      <PlayPauseButton play={play} setPlay={setPlay} />\n      <p>\n        <button onClick={decreaseRate} disabled={rate <= 0.5}>\n          -0.5\n        </button>\n        <button onClick={increaseRate} disabled={rate >= 4}>\n          +0.5\n        </button>\n      </p>\n      <Play howl={howl} rate={rate} onRate={action('onRate')} pause={!play}>\n        {({\n        playing\n      }) => <>Playing: {playing().toString()}</>}\n      </Play>\n    </>;\n}",...rate.parameters?.docs?.source}}},pause.parameters={...pause.parameters,docs:{...pause.parameters?.docs,source:{originalSource:"() => {\n  const {\n    howl,\n    state\n  } = useHowl({\n    src: sound1\n  });\n  const [play, setPlay] = useState(false);\n  return <>\n      <p>\n        Control playback with the <code>pause</code> prop.\n      </p>\n      <p>State: {state}</p>\n      <PlayPauseButton play={play} setPlay={setPlay} />\n      <Play howl={howl} pause={!play} onPlay={action('onPlay')} onPause={action('onPause')}>\n        {({\n        playing\n      }) => <p>Playing: {playing().toString()}</p>}\n      </Play>\n    </>;\n}",...pause.parameters?.docs?.source}}},volume.parameters={...volume.parameters,docs:{...volume.parameters?.docs,source:{originalSource:'() => {\n  const {\n    howl,\n    state\n  } = useHowl({\n    src: sound1\n  });\n  const [play, setPlay] = useState(false);\n  const [volume, setVolume] = useState(0.5);\n  return <>\n      <p>Set the volume. The Play element can change before and during playback.</p>\n      <p>State: {state}</p>\n      <div>\n        <label htmlFor="volume">Volume:</label>\n        <input id="volume" type="range" min={0} max={1} step={0.05} value={volume} onChange={event => setVolume(parseFloat(event.target.value))} />\n      </div>\n      <PlayPauseButton play={play} setPlay={setPlay} />\n      {play && <Play howl={howl} volume={volume} onVolume={action(\'onVolume\')}>\n          {({\n        playing\n      }) => <>Playing: {playing().toString()}</>}\n        </Play>}\n    </>;\n}',...volume.parameters?.docs?.source}}},mute.parameters={...mute.parameters,docs:{...mute.parameters?.docs,source:{originalSource:"() => {\n  const {\n    howl,\n    state\n  } = useHowl({\n    src: sound1\n  });\n  const [play, setPlay] = useState(false);\n  const [mute, setMute] = useState(true);\n  return <>\n      <p>State: {state}</p>\n      <PlayPauseButton play={play} setPlay={setPlay} />\n      <p>\n        {mute ? 'Muted.' : 'Unmuted.'} <button onClick={() => setMute(!mute)}>{mute ? 'Unmute 🔊' : 'Mute 🔇'}</button>\n      </p>\n      {play && <Play howl={howl} mute={mute} onPlay={action('onPlay')} onMute={action('onMute')}>\n          {({\n        playing\n      }) => <>Playing: {playing().toString()}</>}\n        </Play>}\n    </>;\n}",...mute.parameters?.docs?.source}}},fade.parameters={...fade.parameters,docs:{...fade.parameters?.docs,source:{originalSource:"() => {\n  const {\n    howl,\n    state\n  } = useHowl({\n    src: sound1\n  });\n  const [play, setPlay] = useState(false);\n  const [silent, setSilent] = useState<undefined | boolean>(undefined);\n  const [fading, setFading] = useState(false);\n\n  // Request animation frames during fade.\n  const [, setTime] = useState(0);\n  const requestRef = useRef<number | null>(null);\n  const previousTimeRef = useRef(0);\n  const animate = (time: number) => {\n    if (previousTimeRef.current !== undefined) {\n      const deltaTime = time - previousTimeRef.current;\n      setTime(deltaTime);\n    }\n    previousTimeRef.current = time;\n    requestRef.current = requestAnimationFrame(animate);\n  };\n  useEffect(() => {\n    if (!fading) {\n      if (requestRef.current) cancelAnimationFrame(requestRef.current);\n      return;\n    }\n    requestRef.current = requestAnimationFrame(animate);\n    return () => {\n      if (requestRef.current) cancelAnimationFrame(requestRef.current);\n    };\n  }, [fading]);\n  return <>\n      <p>State: {state}</p>\n      <PlayPauseButton play={play} setPlay={setPlay} />\n      <>\n        <button disabled={fading} onClick={() => {\n        setFading(true);\n        setSilent(!silent);\n      }}>\n          {fading ? silent ? 'Fading out...' : 'Fading in...' : silent ? 'Fade in!' : 'Fade out!'}\n        </button>\n        <Play howl={howl} pause={!play} fade={silent === undefined ? undefined : silent ? [1, 0, 2000] : [0, 1, 2000]} onFade={() => setFading(false)}>\n          {({\n          volume\n        }) => <p>Volume is at {(volume() * 100).toFixed(0)}%</p>}\n        </Play>\n      </>\n    </>;\n}",...fade.parameters?.docs?.source}}},seekWithScrubberBar.parameters={...seekWithScrubberBar.parameters,docs:{...seekWithScrubberBar.parameters?.docs,source:{originalSource:'() => {\n  const {\n    howl\n  } = useHowl({\n    src: sound1\n  });\n  const [targetSeek, setTargetSeek] = useState(0);\n  const [play, setPlay] = useState(false);\n  const [scrubbing, setScrubbing] = useState(false);\n  const [pauseDuringScrub, setPauseDuringScrub] = useState(true);\n\n  // Request animation frames in order to render seek smoothly.\n  const [, setTime] = useState(0);\n  const requestRef = useRef<number | null>(null);\n  const previousTimeRef = useRef(0);\n  const animate = (time: number) => {\n    if (previousTimeRef.current !== undefined) {\n      const deltaTime = time - previousTimeRef.current;\n      setTime(deltaTime);\n    }\n    previousTimeRef.current = time;\n    requestRef.current = requestAnimationFrame(animate);\n  };\n  useEffect(() => {\n    if (!play) return;\n    requestRef.current = requestAnimationFrame(animate);\n    return () => {\n      if (requestRef.current) cancelAnimationFrame(requestRef.current);\n    };\n  }, [play]);\n  return <>\n      <div>\n        <input type="checkbox" checked={pauseDuringScrub} onChange={event => setPauseDuringScrub(event.target.checked)} id="pause-during-scrub" />\n        <label htmlFor="pause-during-scrub">Pause while scrubbing</label>\n      </div>\n      <PlayPauseButton play={play} setPlay={setPlay} />\n      <Play howl={howl} seek={targetSeek} pause={!play || pauseDuringScrub && scrubbing} onEnd={() => setPlay(true)} onSeek={action(\'onSeek\')}>\n        {({\n        seek,\n        duration\n      }) => {\n        const position = scrubbing && targetSeek !== undefined ? targetSeek : seek();\n        const length = duration();\n        return <div>\n              <p>\n                {position.toFixed(1)} / {length.toFixed(1)}\n              </p>\n              <input type="range" min={0} max={length} value={position} step={0.1} onChange={e => {\n            const changedPosition = parseFloat(e.target.value);\n            // Remove false positives caused by slow seek() update time.\n            setTargetSeek(changedPosition);\n          }} onMouseDown={() => setTimeout(() => setScrubbing(true), 0)} onMouseUp={() => setTimeout(() => setScrubbing(false), 0)} />\n            </div>;\n      }}\n      </Play>\n    </>;\n}',...seekWithScrubberBar.parameters?.docs?.source}}},basicSprite.parameters={...basicSprite.parameters,docs:{...basicSprite.parameters?.docs,source:{originalSource:"() => {\n  const [digit, setDigit] = useState(0);\n  const [loop, setLoop] = useState(false);\n  const {\n    howl,\n    state\n  } = useHowl({\n    src: [sound2web, sound2mp3],\n    sprite: {\n      1: [0, 450],\n      2: [2000, 250],\n      3: [4000, 350],\n      4: [6000, 380],\n      5: [8000, 340]\n    }\n  });\n  return <>\n      <p>\n        All these digits are loaded from a single sound file and are controlled by one Howl. The Play component will\n        automatically start playing when the selected sprite changes.\n      </p>\n      <p>Selected digit: {digit}</p>\n      <p>State: {state}</p>\n      <div>\n        {[1, 2, 3, 4, 5].map(digit => <button key={digit} onClick={() => {\n        setDigit(digit);\n      }}>\n            {digit}\n          </button>)}\n      </div>\n      <button onClick={() => setLoop(!loop)}>{loop ? 'Disable Looping' : 'Enable Looping'}</button>\n      {digit > 0 ? <Play howl={howl} sprite={`${digit}`} loop={loop} /> : null}\n    </>;\n}",...basicSprite.parameters?.docs?.source}}},complexSprite.parameters={...complexSprite.parameters,docs:{...complexSprite.parameters?.docs,source:{originalSource:"() => {\n  const [digits, setDigits] = useState<Digits>([]);\n  const [playBeat, setPlayBeat] = useState(false);\n  const {\n    howl,\n    state\n  } = useHowl({\n    src: [sound2web, sound2mp3],\n    sprite: {\n      1: [0, 450],\n      2: [2000, 250],\n      3: [4000, 350],\n      4: [6000, 380],\n      5: [8000, 340],\n      beat: [10000, 11163]\n    }\n  });\n  return <>\n      <p>All these sounds are loaded from a single sound file on one Howl.</p>\n      <p>Every time you click a digit, a Play is rendered and played until onEnd is called.</p>\n      <p>Go ahead, play a few sounds at once.</p>\n      <p>State: {state}</p>\n      <div>\n        {[1, 2, 3, 4, 5].map(digit => <button key={digit} onClick={() => {\n        setDigits(digits => [...digits, {\n          digit,\n          time: Date.now()\n        }]);\n      }}>\n            {digit}\n          </button>)}\n      </div>\n      <button onClick={() => setPlayBeat(!playBeat)}>{playBeat ? 'Pause Beat' : 'Play Beat'}</button>\n      <button onClick={() => {\n      const now = Date.now();\n      setDigits(digits => [...digits, {\n        digit: 5,\n        time: now\n      }, {\n        digit: 4,\n        time: now + 1\n      }, {\n        digit: 3,\n        time: now + 2\n      }, {\n        digit: 2,\n        time: now + 3\n      }, {\n        digit: 1,\n        time: now + 4\n      }]);\n    }}>\n        Play all\n      </button>\n      <div>\n        <Play howl={howl} sprite=\"beat\" loop pause={!playBeat}>\n          {({\n          playing\n        }) => <p>Beat Playing: {playing().toString()}</p>}\n        </Play>\n        {digits.map(({\n        digit,\n        time\n      }) => <Play howl={howl} sprite={`${digit}`} key={time} onEnd={() => setDigits(digits => {\n        const targetIndex = digits.findIndex(x => x.time === time);\n        if (targetIndex < 0) return digits;\n        return [...digits.slice(0, targetIndex), ...digits.slice(targetIndex + 1)];\n      })}>\n            {({\n          duration\n        }) => <p>\n                Playing {digit} for {duration()}\n              </p>}\n          </Play>)}\n      </div>\n    </>;\n}",...complexSprite.parameters?.docs?.source}}},errorBadSRC.parameters={...errorBadSRC.parameters,docs:{...errorBadSRC.parameters?.docs,source:{originalSource:"() => {\n  const {\n    howl,\n    state,\n    error\n  } = useHowl({\n    src: 'fake'\n  });\n  return <>\n      {error && <p>Error: {[error.id, error.message].filter(x => x).join(' ')} </p>}\n      <p>State: {state}</p>\n      <Play howl={howl} />\n    </>;\n}",...errorBadSRC.parameters?.docs?.source}}},howlDefaultVolume.parameters={...howlDefaultVolume.parameters,docs:{...howlDefaultVolume.parameters?.docs,source:{originalSource:'() => {\n  const [defaultVolume, setDefaultVolume] = useState(0);\n  const [playVolume, setPlayVolume] = useState(0);\n  const {\n    howl\n  } = useHowl({\n    src: sound1,\n    defaultVolume\n  });\n  const [play, setPlay] = useState(false);\n  return <>\n      <p>\n        Default volume on the howl is 0 to prevent clipping on quiet plays. This example is used for debug on slower\n        devices such as phones.\n      </p>\n      <div>\n        <label>\n          <input type="radio" name="default-volume" checked={defaultVolume === 0} value={0} onChange={event => {\n          if (event.target.checked) {\n            setDefaultVolume(0);\n          }\n        }} />\n          &nbsp;Default volume 0\n        </label>\n        <label>\n          <input type="radio" name="default-volume" checked={defaultVolume === 1} value={1} onChange={event => {\n          if (event.target.checked) {\n            setDefaultVolume(1);\n          }\n        }} />\n          &nbsp;Default volume 1\n        </label>\n      </div>\n      <div>\n        <label>\n          <input type="radio" name="play-volume" checked={playVolume === 0} value={0} onChange={event => {\n          if (event.target.checked) {\n            setPlayVolume(0);\n          }\n        }} />\n          &nbsp;Play volume 0\n        </label>\n        <label>\n          <input type="radio" name="play-volume" checked={playVolume === 1} value={1} onChange={event => {\n          if (event.target.checked) {\n            setPlayVolume(1);\n          }\n        }} />\n          &nbsp;Play volume 1\n        </label>\n      </div>\n      <PlayPauseButton play={play} setPlay={setPlay} />\n\n      {play && <Play howl={howl} volume={playVolume} seek={0.5} />}\n    </>;\n}',...howlDefaultVolume.parameters?.docs?.source}}},swapSource.parameters={...swapSource.parameters,docs:{...swapSource.parameters?.docs,source:{originalSource:"() => {\n  const srcs = ['nonexistent.mp3', sound1, sound2mp3];\n  const [useHtml5, setUseHtml5] = useState(false);\n  const [src, setSrc] = useState(srcs[0]);\n  const {\n    howl,\n    state,\n    error\n  } = useHowl({\n    src: src,\n    html5: useHtml5\n  });\n  return <>\n      <p>Every time a setting is changed on useHowl or Rehowl, the howl instance is reconstructed.</p>\n      <p>It's better to load multiple howls and use Play components than swap the source on a single howl.</p>\n      <p>In this example, you can change the howl's src and whether it's using HTML5 Audio or Web Audio.</p>\n      <p>\n        <strong>Select a sound to play</strong>\n      </p>\n      {srcs.map(srcChoice => <div key={srcChoice}>\n          <label>\n            <input type=\"radio\" name=\"source\" checked={srcChoice === src} value={srcChoice} onChange={event => {\n          if (event.target.checked) {\n            setSrc(srcChoice);\n          }\n        }} />\n            &nbsp;{srcChoice}\n          </label>\n        </div>)}\n      <label style={{\n      display: 'block',\n      marginTop: '1rem'\n    }}>\n        <input type=\"checkbox\" checked={useHtml5} onChange={event => setUseHtml5(event.target.checked)} id=\"html5\" />\n        Use HTML 5 Audio\n      </label>\n\n      <p>\n        <strong>Info</strong>\n      </p>\n      {error && <p>Error: {[error.id, error.message].filter(x => x).join(' ')} </p>}\n      <p>State: {state}</p>\n\n      <Play howl={howl}>{({\n        playing\n      }) => <>Playing: {playing().toString()}</>}</Play>\n    </>;\n}",...swapSource.parameters?.docs?.source}}};const __namedExportsOrder=["renderPlay","noPreload","stop","rate","pause","volume","mute","fade","seekWithScrubberBar","basicSprite","complexSprite","errorBadSRC","howlDefaultVolume","swapSource"]},"./src/Play.tsx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{s:()=>Play});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js");function Play(props){const{howl,pause,sprite,mute,volume=1,seek,fade,stop,rate,loop,children}=props,shouldPlay=!pause&&!stop,[initialized,setInitialized]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(shouldPlay),[playId,setPlayId]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null),[playing,setPlaying]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!0),[stopped,setStopped]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1),[unlocked,setUnlocked]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1),[seeking,setSeeking]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1),onPlay=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),onPlayError=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),onEnd=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),onPause=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),onStop=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),onMute=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),onVolume=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),onSeek=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),onFade=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),onRate=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);return(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{onPlay.current=props.onPlay||null}),[props.onPlay]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{onPlayError.current=props.onPlayError||null}),[props.onPlayError]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{onEnd.current=props.onEnd||null}),[props.onEnd]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{onPause.current=props.onPause||null}),[props.onPause]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{onStop.current=props.onStop||null}),[props.onStop]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{onMute.current=props.onMute||null}),[props.onMute]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{onVolume.current=props.onVolume||null}),[props.onVolume]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{onSeek.current=props.onSeek||null}),[props.onSeek]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{onFade.current=props.onFade||null}),[props.onFade]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{onRate.current=props.onRate||null}),[props.onRate]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{initialized||shouldPlay&&setInitialized(!0)}),[initialized,shouldPlay]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{if(!howl||!shouldPlay||!initialized)return;const currentPlayId=howl.play(sprite);return setPlayId(currentPlayId),howl.volume(volume,currentPlayId),void 0!==mute&&howl.mute(mute,currentPlayId),void 0!==rate&&howl.rate(rate,currentPlayId),howl.once("play",(id=>{id===currentPlayId&&setUnlocked(!0)})),howl.on("play",(id=>{id===currentPlayId&&onPlay.current&&onPlay.current()})),howl.on("playerror",(id=>{id===currentPlayId&&onPlayError.current&&onPlayError.current()})),howl.on("pause",(id=>{id===currentPlayId&&onPause.current&&onPause.current()})),howl.on("end",(id=>{id===currentPlayId&&onEnd.current&&onEnd.current()})),howl.on("stop",(id=>{id===currentPlayId&&onStop.current&&onStop.current()})),howl.on("mute",(id=>{id===currentPlayId&&onMute.current&&onMute.current()})),howl.on("volume",(id=>{id===currentPlayId&&onVolume.current&&onVolume.current()})),howl.on("rate",(id=>{id===currentPlayId&&onRate.current&&onRate.current()})),howl.on("seek",(id=>{id===currentPlayId&&(setSeeking(!1),onSeek.current&&onSeek.current())})),howl.on("fade",(id=>{id===currentPlayId&&onFade.current&&onFade.current()})),()=>{howl.stop(currentPlayId),setInitialized(!1),setUnlocked(!1),howl.off("play",void 0,currentPlayId),howl.off("playerror",void 0,currentPlayId),howl.off("pause",void 0,currentPlayId),howl.off("end",void 0,currentPlayId),howl.off("stop",void 0,currentPlayId),howl.off("mute",void 0,currentPlayId),howl.off("volume",void 0,currentPlayId),howl.off("rate",void 0,currentPlayId),howl.off("seek",void 0,currentPlayId),howl.off("fade",void 0,currentPlayId),setPlayId(null)}}),[initialized,howl,sprite]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{howl&&playId&&unlocked&&(stop?stopped||(howl.stop(playId),setStopped(!0),setPlaying(!1)):playing&&pause?(howl.pause(playId),setStopped(!1),setPlaying(!1)):playing||pause||(howl.play(playId),setStopped(!1),setPlaying(!0)))}),[howl,playId,stopped,unlocked,playing,pause,stop]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{howl&&playId&&unlocked&&void 0!==mute&&howl.mute(mute,playId)}),[howl,playId,unlocked,mute]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{howl&&playId&&unlocked&&void 0!==volume&&howl.volume(volume,playId)}),[howl,playId,unlocked,volume]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{howl&&playId&&unlocked&&void 0!==seek&&(setSeeking(!0),howl.seek(seek,playId))}),[howl,playId,unlocked,seek]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{if(!howl||!playId||!unlocked)return;if(!fade)return;const[from,to,duration]=fade;howl.fade(from,to,duration,playId)}),[howl,playId,unlocked,JSON.stringify(fade)]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{howl&&playId&&unlocked&&void 0!==rate&&howl.rate(rate,playId)}),[howl,playId,unlocked,rate]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{howl&&playId&&unlocked&&void 0!==loop&&howl.loop(loop,playId)}),[howl,playId,unlocked,loop]),children&&howl?children({duration:()=>howl&&playId?sprite?howl.duration(playId):howl.duration():0,playing:()=>!(!howl||!playId)&&howl.playing(playId),seek:()=>{if(!howl||!playId)return 0;if(seeking&&void 0!==seek)return seek;const position=howl.seek(playId);return"number"!=typeof position?0:position},volume:()=>{if(!howl||!playId)return void 0===volume?1:volume;const currentVolume=howl.volume(playId);return"number"!=typeof currentVolume?0:currentVolume}}):null}try{Play.displayName="Play",Play.__docgenInfo={description:"Plays and controls sounds from a Howl.\n\nThe Howl instance, provided by the `howl` prop, can come from `useHowl`,\n`<Rehowl />`, or provided from your own use of howler.js\n\nYou can render **multiple `<Play />` components** for a single\nHowl instance in order to play multiple sounds or sprites at once.\n\nEvent handlers fire only for the `<Play />` that they correspond to,\nand not for every sound playing off of the Howl instance like in howler.js",displayName:"Play",props:{howl:{defaultValue:null,description:"Instance of Howl to play sounds from.",name:"howl",required:!0,type:{name:"Howl | null"}},sprite:{defaultValue:null,description:"If specified, play a sprite instead of the entire source.",name:"sprite",required:!1,type:{name:"string | undefined"}},pause:{defaultValue:{value:"false"},description:"Pause playback.",name:"pause",required:!1,type:{name:"boolean | undefined"}},volume:{defaultValue:{value:"1"},description:"Control playback volume, from 0 to 1.",name:"volume",required:!1,type:{name:"number | undefined"}},mute:{defaultValue:{value:"false"},description:"Mute playback.",name:"mute",required:!1,type:{name:"boolean | undefined"}},stop:{defaultValue:{value:"false"},description:"While true, playback will be stopped.\n\nStopping sets seek to 0 and allows Howl to garbage collect the sound.\n\nConsider setting pause to true and seek to 0 instead if you're playing many sounds at once.",name:"stop",required:!1,type:{name:"boolean | undefined"}},seek:{defaultValue:null,description:"The time to seek this sound to in seconds.\n\nThe seek only applies once per value change.",name:"seek",required:!1,type:{name:"number | undefined"}},rate:{defaultValue:{value:"1"},description:"Set the rate of playback, from 0.5 to 4.",name:"rate",required:!1,type:{name:"number | undefined"}},loop:{defaultValue:{value:"false"},description:"Whether to loop the track or sprite on play end.",name:"loop",required:!1,type:{name:"boolean | undefined"}},fade:{defaultValue:null,description:"Fade a currently playing sound between two volumes.\n\nValues are [from, to, duration].",name:"fade",required:!1,type:{name:"[number, number, number] | undefined"}},onPlay:{defaultValue:null,description:"Listen for play events.\n\nFires once when <Play /> is mounted even if the sound starts in a stopped or paused state.",name:"onPlay",required:!1,type:{name:"(() => void) | undefined"}},onPlayError:{defaultValue:null,description:"Fires when play fails and provides the error message or code.",name:"onPlayError",required:!1,type:{name:"((message: string) => void) | undefined"}},onEnd:{defaultValue:null,description:"Fires when play ends, meaning the sound reached its end, including every time a loop has finished.",name:"onEnd",required:!1,type:{name:"(() => void) | undefined"}},onPause:{defaultValue:null,description:"Fires when this sound is paused, including on <Play /> mount if `pause` or `stop` is true.",name:"onPause",required:!1,type:{name:"(() => void) | undefined"}},onStop:{defaultValue:null,description:"Fires when the sound is stopped.",name:"onStop",required:!1,type:{name:"(() => void) | undefined"}},onMute:{defaultValue:null,description:"Fires when the sound is muted or unmuted.",name:"onMute",required:!1,type:{name:"(() => void) | undefined"}},onVolume:{defaultValue:null,description:"Fires when the sound's volume is set, including on <Play /> mount if `volume` is set.",name:"onVolume",required:!1,type:{name:"(() => void) | undefined"}},onSeek:{defaultValue:null,description:"Fires when the sound is seeked.",name:"onSeek",required:!1,type:{name:"(() => void) | undefined"}},onFade:{defaultValue:null,description:"Fires when this sound's fade is complete.",name:"onFade",required:!1,type:{name:"(() => void) | undefined"}},onRate:{defaultValue:null,description:"Fires when the rate of playback for this sound is changed.",name:"onRate",required:!1,type:{name:"(() => void) | undefined"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/Play.tsx#Play"]={docgenInfo:Play.__docgenInfo,name:"Play",path:"src/Play.tsx#Play"})}catch(__react_docgen_typescript_loader_error){}},"./src/useHowl.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{$:()=>useHowl});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js"),howler__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/howler/dist/howler.js");function useHowl(howlOptions){const{src,sprite,format,html5,preload,xhr,defaultVolume=0}=howlOptions,[howl,setHowl]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null),[,setState]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)("unloaded"),[,setLocked]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!0),[error,setError]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);if((0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{const newHowl=new howler__WEBPACK_IMPORTED_MODULE_1__.Howl({autoplay:!1,format,html5,onload:()=>setState("loaded"),onloaderror:(id,message)=>setError({id,message}),onunlock:()=>{setLocked(!1)},preload,sprite,src,volume:defaultVolume,xhr});return setHowl(newHowl),()=>{setHowl(null),setState("unloaded"),setLocked(!0),setError(null),newHowl&&(newHowl.off(),newHowl.stop(),newHowl.unload())}}),[JSON.stringify(src),JSON.stringify(sprite),JSON.stringify(format),html5,xhr,preload,defaultVolume]),!howl)return{howl:null,error:null,state:"unloaded",load:()=>{}};const state=howl.state();return{howl,error,state,load:"unloaded"===state?()=>{howl&&howl.load(),setState("loading")}:()=>{}}}try{useHowl.displayName="useHowl",useHowl.__docgenInfo={description:"A hook to get a Howl instance for use with `<Play />`.\n\nRecommended when using Rehowl from a function component. If you're\nusing a class component, you'll need to use `<Rehowl />`.",displayName:"useHowl",props:{src:{defaultValue:null,description:"The sources to the track(s) to be loaded for the sound (URLs or base64 data URIs).\n\nThese should be in order of preference, howler.js will automatically load the first\none that is compatible with the current browser.\n\nIf your files have no extensions, you will need to explicitly specify the extension\nusing the `format` prop.",name:"src",required:!0,type:{name:"string | string[]"}},sprite:{defaultValue:null,description:"Define a sound sprite for the sound.\n\nThe offset and duration are defined in milliseconds.\n\nA third (optional) parameter is available to set a sprite as looping, but you can just\nset `loop` to `true` on the `<Play />` component to achieve this as well.",name:"sprite",required:!1,type:{name:"SoundSpriteDefinitions | undefined"}},format:{defaultValue:null,description:"Array of formats corresponding to the sources provided if it's not inferable from the file name.",name:"format",required:!1,type:{name:"string[] | undefined"}},html5:{defaultValue:{value:"false"},description:"Set to true to use html5 audio instead of Web Audio.\n\nThis should be used for large audio files so that you don't have\nto wait for the full file to be downloaded and decoded before playing.",name:"html5",required:!1,type:{name:"boolean | undefined"}},preload:{defaultValue:{value:"true"},description:"Set to false in order to prevent loading the file until you call the returned `load()` function.\n\nOtherwise, howler will start loading your file immediately.",name:"preload",required:!1,type:{name:"boolean | undefined"}},xhr:{defaultValue:null,description:"Whether or not to enable the withCredentials flag on XHR requests used to fetch audio files when using Web Audio API.",name:"xhr",required:!1,type:{name:"{ method?: string | undefined; headers?: Record<string, string> | undefined; withCredentials?: boolean | undefined; } | undefined"}},defaultVolume:{defaultValue:{value:"0"},description:"Default starting volume for Plays. Defaults to muted to prevent clipping of low-volume plays.\n\nSet it to your desired Play volume if you find the beginning of your plays getting clipped.",name:"defaultVolume",required:!1,type:{name:"number | undefined"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/useHowl.ts#useHowl"]={docgenInfo:useHowl.__docgenInfo,name:"useHowl",path:"src/useHowl.ts#useHowl"})}catch(__react_docgen_typescript_loader_error){}},"./stories/static/audio/sound1.mp3":(module,__unused_webpack_exports,__webpack_require__)=>{module.exports=__webpack_require__.p+"static/media/sound1.ba7707f0.mp3"}}]);